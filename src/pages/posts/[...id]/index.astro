---
import Breadcrumbs from '@/components/Breadcrumbs.astro'
import Link from '@/components/Link.astro'
import PostHead from '@/components/PostHead.astro'
import PostNavigation from '@/components/PostNavigation.astro'
import SubpostsHeader from '@/components/SubpostsHeader.astro'
import SubpostsSidebar from '@/components/SubpostsSidebar.astro'
import TOCHeader from '@/components/TOCHeader.astro'
import TOCSidebar from '@/components/TOCSidebar.astro'
import { badgeVariants } from '@/components/ui/badge'
import { Button } from '@/components/ui/button'
import Layout from '@/layouts/Layout.astro'
import {
  getAdjacentPosts,
  getAllPostsAndSubposts,
  getCombinedReadingTime,
  getParentId,
  getParentPost,
  getPostReadingTime,
  getSubpostCount,
  getTOCSections,
  hasSubposts,
  isSubpost,
  parseAuthors,
} from '@/lib/data-utils'
import { formatDate } from '@/lib/utils'
import { Icon } from 'astro-icon/components'
import { Image } from 'astro:assets'
import { render } from 'astro:content'

export async function getStaticPaths() {
  const posts = await getAllPostsAndSubposts()
  return posts.map((post) => ({
    params: { id: post.id },
    props: post,
  }))
}

const post = Astro.props
const currentPostId = Astro.params.id
const { Content, headings } = await render(post)
const authors = await parseAuthors(post.data.authors ?? [])
const rawMarkdown = (post.body ?? '').trim()
const showMarkdownActions = rawMarkdown.length > 0
const markdownUrl = `/posts/${currentPostId}/markdown`

const serializeForInlineScript = (value: string) =>
  JSON.stringify(value)
    .replace(/</g, '\\u003c')
    .replace(/>/g, '\\u003e')
    .replace(/\u2028/g, '\\u2028')
    .replace(/\u2029/g, '\\u2029')

const isCurrentSubpost = isSubpost(currentPostId)
const navigation = await getAdjacentPosts(currentPostId)
const parentPost = isCurrentSubpost ? await getParentPost(currentPostId) : null

const hasChildPosts = await hasSubposts(currentPostId)
const subpostCount = !isCurrentSubpost
  ? await getSubpostCount(currentPostId)
  : 0
const postReadingTime = await getPostReadingTime(currentPostId)
const combinedReadingTime =
  hasChildPosts && !isCurrentSubpost
    ? await getCombinedReadingTime(currentPostId)
    : null

const tocSections = await getTOCSections(currentPostId)
---

<Layout>
  <PostHead slot="head" post={post} />
  <script slot="head" src="/scripts/post-enhancements.js" defer is:inline
  ></script>
  {
    (hasChildPosts || isCurrentSubpost) && (
      <SubpostsHeader
        slot="subposts-navigation"
        parentId={isCurrentSubpost ? getParentId(currentPostId) : currentPostId}
      />
    )
  }
  {
    headings?.length > 0 &&
      !(
        isCurrentSubpost &&
        headings.length === 1 &&
        headings[0].text === post.data.title
      ) && <TOCHeader slot="table-of-contents" headings={headings} />
  }
  <span
    slot="reading-status"
    id="reading-status-chip"
    class="reading-status-chip border-border/60 bg-background/70 text-foreground/70 hidden items-center gap-2 rounded-full border px-3 py-[0.35rem] text-[0.7rem] font-semibold tracking-[0.2em] uppercase shadow-sm backdrop-blur md:inline-flex"
    role="status"
    aria-live="polite"
  >
    <svg
      class="text-primary size-4"
      viewBox="0 0 24 24"
      role="presentation"
      aria-hidden="true"
    >
      <circle
        class="text-primary/15"
        cx="12"
        cy="12"
        r="10"
        fill="none"
        stroke="currentColor"
        stroke-width="2"></circle>
      <circle
        id="reading-status-circle"
        class="text-primary"
        cx="12"
        cy="12"
        r="10"
        fill="none"
        stroke="currentColor"
        stroke-width="2"
        stroke-dasharray="62.83"
        stroke-dashoffset="62.83"
        transform="rotate(-90 12 12)"></circle>
    </svg>
    <span id="reading-status-label">Reading progress 0%</span>
  </span>
  <section
    class="grid grid-cols-[minmax(0px,1fr)_min(calc(var(--breakpoint-md)-2rem),100%)_minmax(0px,1fr)] gap-y-6"
  >
    <div class="col-start-2">
      <Breadcrumbs
        items={[
          { href: '/posts', label: 'Posts', icon: 'lucide:library-big' },
          ...(isCurrentSubpost && parentPost
            ? [
                {
                  href: `/posts/${parentPost.id}`,
                  label: parentPost.data.title,
                  icon: 'lucide:book-open',
                },
                {
                  href: `/posts/${currentPostId}`,
                  label: post.data.title,
                  icon: 'lucide:file-text',
                },
              ]
            : [
                {
                  href: `/posts/${currentPostId}`,
                  label: post.data.title,
                  icon: 'lucide:book-open-text',
                },
              ]),
        ]}
      />
    </div>

    {
      post.data.image && (
        <Image
          src={post.data.image}
          alt={post.data.title}
          width={1200}
          height={630}
          class="col-span-full mx-auto w-full max-w-5xl object-cover"
        />
      )
    }

    <section class="col-start-2 flex flex-col gap-y-6 text-center">
      <div class="flex flex-col">
        <h1
          class="mb-2 scroll-mt-31 text-3xl leading-tight font-medium sm:text-4xl"
          id="post-title"
        >
          {post.data.title}
        </h1>

        <div
          class="text-muted-foreground divide-border mb-4 flex flex-col items-center justify-center divide-y text-xs sm:flex-row sm:flex-wrap sm:divide-x sm:divide-y-0 sm:text-sm"
        >
          {
            authors.length > 0 && (
              <div class="flex w-full flex-wrap items-center justify-center gap-x-2 gap-y-1 py-2 sm:w-fit sm:px-2 sm:py-0 first:sm:pl-0 last:sm:pr-0">
                {authors.map((author) => (
                  <div class="flex items-center gap-x-1.5">
                    {author.isRegistered ? (
                      <Link
                        href={`/authors/${author.id}`}
                        underline
                        class="text-foreground"
                      >
                        <span>{author.name}</span>
                      </Link>
                    ) : (
                      <span>{author.name}</span>
                    )}
                  </div>
                ))}
              </div>
            )
          }

          <div
            class="flex w-full items-center justify-center gap-2 py-2 sm:w-fit sm:px-2 sm:py-0 first:sm:pl-0 last:sm:pr-0"
          >
            <span>{formatDate(post.data.pubDatetime as Date)}</span>
          </div>

          <div
            class="flex w-full items-center justify-center gap-2 py-2 sm:w-fit sm:px-2 sm:py-0 first:sm:pl-0 last:sm:pr-0"
          >
            <span>
              {postReadingTime}
              {
                combinedReadingTime &&
                  combinedReadingTime !== postReadingTime && (
                    <span class="text-muted-foreground">
                      {' '}
                      ({combinedReadingTime} total)
                    </span>
                  )
              }
            </span>
          </div>
          {
            subpostCount > 0 && (
              <div class="flex w-full items-center justify-center gap-1 py-2 sm:w-fit sm:px-2 sm:py-0 first:sm:pl-0 last:sm:pr-0">
                <Icon name="lucide:file-text" class="size-3" />
                {subpostCount} subpost{subpostCount === 1 ? '' : 's'}
              </div>
            )
          }
        </div>
        <div class="flex flex-wrap justify-center gap-2">
          {
            post.data.tags &&
              post.data.tags.length > 0 &&
              post.data.tags.map((tag) => (
                <a
                  href={`/tags/${tag}`}
                  class={badgeVariants({ variant: 'muted' })}
                >
                  <Icon name="lucide:hash" class="size-3" />
                  {tag}
                </a>
              ))
          }
        </div>
        {
          showMarkdownActions && (
            <div class="mt-4 flex justify-center">
              <div
                class="border-border bg-background/70 text-foreground/80 relative inline-flex items-stretch rounded-md border text-sm font-medium"
                data-markdown-actions
              >
                <a
                  href={markdownUrl}
                  target="_blank"
                  rel="noopener noreferrer"
                  class="hover:bg-muted focus-visible:ring-ring/40 flex items-center gap-2 rounded-l-md px-3 py-2 transition-colors focus-visible:ring-2 focus-visible:outline-none"
                  data-markdown-view
                >
                  <Icon
                    name="lucide:file-text"
                    class="text-muted-foreground size-4"
                  />
                  <span>View Markdown</span>
                  <Icon
                    name="lucide:arrow-up-right"
                    class="text-muted-foreground size-3"
                  />
                </a>
                <button
                  type="button"
                  class="border-border text-muted-foreground hover:bg-muted focus-visible:ring-ring/40 flex items-center justify-center rounded-r-md border-l px-2 py-2 transition-colors focus-visible:ring-2 focus-visible:outline-none"
                  data-markdown-menu-toggle
                  aria-haspopup="menu"
                  aria-expanded="false"
                  aria-label="Toggle markdown actions"
                >
                  <Icon name="lucide:chevron-down" class="size-3" />
                </button>
                <div
                  class="border-border bg-background/90 absolute top-full right-0 z-30 mt-2 hidden min-w-[12rem] rounded-md border p-1"
                  data-markdown-menu
                  role="menu"
                  aria-label="Markdown actions"
                >
                  <button
                    type="button"
                    class="text-foreground/80 hover:bg-muted focus-visible:ring-ring/40 flex w-full items-center gap-2 rounded-md px-3 py-2 text-sm transition-colors focus-visible:ring-2 focus-visible:outline-none"
                    data-markdown-copy
                    data-state="idle"
                    role="menuitem"
                  >
                    <Icon
                      name="lucide:copy"
                      class="text-muted-foreground size-4"
                    />
                    <span data-copy-label>Copy Markdown</span>
                  </button>
                </div>
              </div>
            </div>
          )
        }
      </div>

      <PostNavigation
        newerPost={navigation.newer}
        olderPost={navigation.older}
        parentPost={isCurrentSubpost ? navigation.parent : undefined}
      />
    </section>

    {
      tocSections.length > 0 && (
        <TOCSidebar sections={tocSections} currentPostId={currentPostId} />
      )
    }

    <article id="article" class="prose col-start-2 max-w-none">
      <Content />
    </article>

    {
      (hasChildPosts || isCurrentSubpost) && (
        <SubpostsSidebar
          parentId={
            isCurrentSubpost ? getParentId(currentPostId) : currentPostId
          }
          className="w-64"
        />
      )
    }

    <PostNavigation
      newerPost={navigation.newer}
      olderPost={navigation.older}
      parentPost={isCurrentSubpost ? navigation.parent : undefined}
    />
  </section>

  <script is:inline>
    ;(() => {
      const state = (window.__readingStatusChip =
        window.__readingStatusChip || {
          cleanup: null,
        })

      const scheduleIdle =
        window.__scheduleIdle ||
        ((callback) => {
          if ('requestIdleCallback' in window) {
            window.requestIdleCallback(callback, { timeout: 300 })
          } else {
            window.setTimeout(callback, 120)
          }
        })

      const RADIUS = 10
      const CIRCUMFERENCE = 2 * Math.PI * RADIUS

      const cleanup = () => {
        if (typeof state.cleanup === 'function') {
          state.cleanup()
        }
        state.cleanup = null
      }

      const computeProgress = () => {
        const root = document.documentElement
        if (!root) return 0

        const scrollHeight = Math.max(root.scrollHeight - window.innerHeight, 0)
        const scrollTop = Math.max(window.scrollY || root.scrollTop || 0, 0)
        if (scrollHeight <= 0) {
          return 0
        }
        return Math.min(Math.round((scrollTop / scrollHeight) * 100), 100)
      }

      const bind = () => {
        const chip = document.getElementById('reading-status-chip')
        const circle = document.getElementById('reading-status-circle')
        const label = document.getElementById('reading-status-label')

        if (!chip || !circle || !label) {
          return null
        }

        circle.style.strokeDasharray = CIRCUMFERENCE.toString()
        circle.style.strokeDashoffset = CIRCUMFERENCE.toString()

        let lastProgress = null

        const setProgress = (value) => {
          if (typeof value !== 'number' || Number.isNaN(value)) {
            return
          }

          const clamped = Math.min(Math.max(Math.round(value), 0), 100)
          if (clamped === lastProgress) {
            return
          }

          const dashOffset = CIRCUMFERENCE * (1 - clamped / 100)
          circle.style.strokeDashoffset = dashOffset.toString()

          const message = `Reading progress ${clamped}%`
          if (label.textContent !== message) {
            label.textContent = message
          }

          lastProgress = clamped
        }

        const manager = window.__scrollManager
        if (manager?.subscribe) {
          const unsubscribe = manager.subscribe((detail) => {
            if (!detail) return
            setProgress(detail.progress)
          })

          return () => {
            if (typeof unsubscribe === 'function') {
              unsubscribe()
            }
            lastProgress = null
          }
        }

        let ticking = false
        const onScroll = () => {
          if (ticking) return
          ticking = true
          window.requestAnimationFrame(() => {
            ticking = false
            setProgress(computeProgress())
          })
        }

        window.addEventListener('scroll', onScroll, { passive: true })
        window.addEventListener('resize', onScroll, { passive: true })
        setProgress(computeProgress())

        return () => {
          window.removeEventListener('scroll', onScroll)
          window.removeEventListener('resize', onScroll)
          lastProgress = null
        }
      }

      const init = () => {
        cleanup()
        const teardown = bind()
        if (teardown) {
          state.cleanup = teardown
        }
      }

      const queueInit = () => {
        scheduleIdle(() => {
          window.requestAnimationFrame(() => {
            init()
          })
        })
      }

      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', queueInit, { once: true })
      } else {
        queueInit()
      }

      document.addEventListener('astro:page-load', queueInit)
      document.addEventListener('astro:after-swap', () => {
        cleanup()
        queueInit()
      })
      document.addEventListener('astro:before-swap', cleanup)
    })()
  </script>

  <Button
    variant="outline"
    size="icon"
    className="group fixed right-8 bottom-8 z-50 hidden"
    id="scroll-to-top"
    title="Scroll to top"
    aria-label="Scroll to top"
  >
    <Icon
      name="lucide:arrow-up"
      class="mx-auto size-4 transition-all group-hover:-translate-y-0.5"
    />
  </Button>

  <script>
    document.addEventListener('astro:page-load', () => {
      const scrollToTopButton = document.getElementById('scroll-to-top')
      const footer = document.querySelector('footer')

      if (scrollToTopButton && footer) {
        scrollToTopButton.addEventListener('click', () => {
          window.scrollTo({ top: 0, behavior: 'smooth' })
        })

        window.addEventListener('scroll', () => {
          const footerRect = footer.getBoundingClientRect()
          const isFooterVisible = footerRect.top <= window.innerHeight

          scrollToTopButton.classList.toggle(
            'hidden',
            window.scrollY <= 300 || isFooterVisible,
          )
        })
      }
    })
  </script>
</Layout>

{
  showMarkdownActions && (
    <script
      type="application/json"
      id="post-markdown-source"
      is:inline
      set:html={serializeForInlineScript(rawMarkdown)}
    />
  )
}
<script is:inline>
  ;(() => {
    const LABEL_IDLE = 'Copy Markdown'
    const LABEL_SUCCESS = 'Copied!'
    const LABEL_ERROR = 'Copy failed'

    const state = (window.__markdownActions = window.__markdownActions || {
      cleanup: null,
    })

    const bind = () => {
      const sourceEl = document.getElementById('post-markdown-source')
      const actions = document.querySelector('[data-markdown-actions]')
      const menu = document.querySelector('[data-markdown-menu]')
      const toggle = document.querySelector('[data-markdown-menu-toggle]')
      const copyButton = document.querySelector('[data-markdown-copy]')
      const copyLabel = document.querySelector('[data-copy-label]')

      if (
        !sourceEl ||
        !actions ||
        !menu ||
        !toggle ||
        !copyButton ||
        !copyLabel
      ) {
        return
      }

      if (typeof state.cleanup === 'function') {
        state.cleanup()
      }

      let raw = sourceEl.textContent ?? ''
      try {
        raw = JSON.parse(raw)
      } catch {
        // fall back to raw text if JSON parsing fails
      }

      let isOpen = false
      const setMenu = (open) => {
        isOpen = open
        menu.classList.toggle('hidden', !open)
        menu.dataset.open = open ? 'true' : 'false'
        toggle.setAttribute('aria-expanded', open ? 'true' : 'false')
      }

      const openMenu = () => setMenu(true)
      const closeMenu = () => setMenu(false)
      setMenu(false)

      const onToggleClick = (event) => {
        event.preventDefault()
        if (isOpen) {
          closeMenu()
        } else {
          openMenu()
        }
      }

      const onDocumentClick = (event) => {
        const target = event.target
        if (target instanceof Node && !actions.contains(target) && isOpen) {
          closeMenu()
        }
      }

      const onKeydown = (event) => {
        if (event.key === 'Escape' && isOpen) {
          closeMenu()
        }
      }

      const setCopyState = (label, state) => {
        copyLabel.textContent = label
        copyButton.dataset.state = state
      }

      const reset = () => {
        window.setTimeout(() => {
          setCopyState(LABEL_IDLE, 'idle')
        }, 1400)
      }

      const writeToClipboard = async (text) => {
        if (
          navigator.clipboard &&
          typeof navigator.clipboard.writeText === 'function'
        ) {
          await navigator.clipboard.writeText(text)
          return
        }

        if (typeof window.prompt === 'function') {
          window.prompt('Copy this markdown and press Enter to continue.', text)
          return
        }

        throw new Error('Clipboard access is unavailable')
      }

      const onCopyClick = async () => {
        try {
          await writeToClipboard(raw)
          setCopyState(LABEL_SUCCESS, 'copied')
          reset()
        } catch {
          setCopyState(LABEL_ERROR, 'error')
          reset()
        } finally {
          closeMenu()
        }
      }

      toggle.addEventListener('click', onToggleClick)
      document.addEventListener('click', onDocumentClick)
      document.addEventListener('keydown', onKeydown)
      copyButton.addEventListener('click', onCopyClick)

      state.cleanup = () => {
        toggle.removeEventListener('click', onToggleClick)
        document.removeEventListener('click', onDocumentClick)
        document.removeEventListener('keydown', onKeydown)
        copyButton.removeEventListener('click', onCopyClick)
        closeMenu()
        state.cleanup = null
      }
    }

    const init = () => {
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', bind, { once: true })
      } else {
        bind()
      }
    }

    init()
    document.addEventListener('astro:page-load', bind)
    document.addEventListener('astro:before-swap', () => {
      if (typeof state.cleanup === 'function') {
        state.cleanup()
      }
    })
  })()
</script>

<script>
  if (document.querySelector('.katex')) {
    if (!document.querySelector('link[href*="katex.min.css"]')) {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href =
        'https://cdn.jsdelivr.net/npm/katex@0.16.22/dist/katex.min.css'
      document.head.appendChild(link)
    }
  }
</script>
